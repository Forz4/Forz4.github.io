<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>云南游记</title>
      <link href="/2019/03/21/YunNan/"/>
      <url>/2019/03/21/YunNan/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/21/YunNan/屏幕快照 2019-01-12 12.05.37.png" alt><br>云南之行，持续更新…<br><a id="more"></a></p><h1 id="彩云之南"><a href="#彩云之南" class="headerlink" title="彩云之南"></a>彩云之南</h1><h2 id="0-序"><a href="#0-序" class="headerlink" title="0. 序"></a>0. <strong>序</strong></h2><p>回上海一周了才来写这篇游记的主要原因就是－－－<strong>懒</strong>。不过说实在的，云南这个地方真的是心心念念了很久但一直没能去成，什么四季如春的昆明、心旷神怡的泸沽湖、艳遇之都丽江、风花雪月的大理，都只是出现在别人的朋友圈里面。</p><p>云南这地方好是好啊大家都知道，但是云南这地方也真是大啊，各大主要的景点分散在云南的各个地方，没有个十天半个月都没办法玩个痛快。这次趁着2019的元旦，前后纠结了几天年假和调休，最终还是来到了彩云之南。</p><h2 id="1-行前准备"><a href="#1-行前准备" class="headerlink" title="1. 行前准备"></a>1. <strong>行前准备</strong></h2><h3 id="旅行计划"><a href="#旅行计划" class="headerlink" title="旅行计划"></a><strong>旅行计划</strong></h3><p>行前俩人也没做什么准备，不过倒是意外发现了mac上面numbers提供的行程计划表格是真不错</p><p><img src="/2019/03/21/YunNan/屏幕快照 2019-01-12 11.56.24.png" alt="屏幕快照 2019-01-12 11.56.24"></p><p><img src="/2019/03/21/YunNan/屏幕快照 2019-01-12 11.57.05.png" alt="屏幕快照 2019-01-12 11.57.05"></p><p><img src="/2019/03/21/YunNan/屏幕快照 2019-01-12 11.57.48.png" alt="屏幕快照 2019-01-12 11.57.48"></p><p>其实主要就是包括了交通、住宿的情况，紧急联系方式等（装箱单有秘密，就没放图），但是对于旅游计划来说也是足够了，以后出去玩也可以用这个来计划吧。</p><h3 id="路线选择"><a href="#路线选择" class="headerlink" title="路线选择"></a><strong>路线选择</strong></h3><p><strong>昆明</strong>是云南的省会，在云南的中东部，作为各地进出云南的中转点会比较合适，这次我们选择上海直飞进出昆明，路上三个多小时完全可以接受。除了昆明之外，剩下的几个景点的玩法就有讲究了，<strong>西双版纳</strong>在云南的南部，接近缅甸和老挝的边境了，属于一个比较独立的景点，基本上只能飞机进出；<strong>泸沽湖、丽江、大理</strong>三个地方在地理上从北到南一字排列，泸沽湖到丽江只有200KM左右，但是由于全都是山路，所以开车要接近4个小时；丽江到大理则全程有高速公路，开车2小时左右即可到达。</p><p>我们为了尽量不走回头路，选择从昆明先飞版纳，玩完版纳之后直飞丽江，这两段的航班班次不多但是感觉票也没那么难买，票价也可以接受吧；到丽江后直接先北上去泸沽湖玩上一天，然后原路返回丽江，在丽江主要就是上雪山游古镇，之后再向南去大理，领略了苍山洱海之后坐动车回昆明，这一段动车要2个小时，班次也多很方便。这样玩下来的话总共有四次飞行，一次动车，其他都是走汽车，只走了泸沽湖和丽江这一段回头路（因为没办法），大体上覆盖了云南主流的几个大景点（由于天气原因没去香格里拉），如果你的计划出行时间是8-9天的话，这个行程路线总的来说还是不错的。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a><strong>注意事项</strong></h3><ol><li>云南真的特别特别干燥。所以一定要带润唇膏，晚上不冷的话尽量不要开空调，不然早上起来嘴巴干裂！</li><li>云南的紫外线真的特别强。还好我们是冬天去，本来穿的比较多，起码四肢没啥事，但是在太阳下站久了真的是晒的脑仁儿疼，在昆明坐的士的时候，隔着一条牛仔裤我感觉我的大腿晒的很痛。anyway，一定要带好防晒、墨镜、帽子。</li><li>云南真的是一个很难穿衣服的地方。每个地方都是早晚温差巨大，早上一起来能把人冻死，到了中午，站在太阳下你热得想穿脱毛衣，就很无奈。而且西双版纳常年20几度，而到高海拔得丽江泸沽湖又只有不到5度，穿多少衣服带多少衣服真的是很愁。</li></ol><p><strong>!!!废话不多说，LET’S GO!!!</strong></p><p><img src="/2019/03/21/YunNan/thumb_IMG_6732_1024.jpg" alt="thumb_IMG_6732_1024"></p><h2 id="2-春城昆明"><a href="#2-春城昆明" class="headerlink" title="2. 春城昆明"></a><strong>2. 春城昆明</strong></h2><p>坦率地说，除了过桥米线之外我对昆明真的是一无所知了，甚至都觉得昆明没有什么可玩的。28号得中午到的昆明，一下飞机准备先搞一餐大的，来到了机场旁边的一家还比较有名的<a href="http://www.dianping.com/shop/96211414" target="_blank" rel="noopener">小黄牛火锅店</a>，店家提供了从机场到店里的免费接机服务，这一点还是很贴心的。我们俩人点了几个特色菜尝尝：</p><p>半斤牛肉和牛杂用来在火锅里涮，味道还是比较鲜美的，每一片肉比较大</p><p><img src="/2019/03/21/YunNan/thumb_IMG_6735_1024.jpg" alt="thumb_IMG_6735_1024"></p><p>炸牛肠就一个字，油。最后没吃完</p><p><img src="/2019/03/21/YunNan/thumb_IMG_6739_1024.jpg" alt="thumb_IMG_6739_1024"></p><p>牛干巴也很油啊（虽然不知道什么是干巴，反正不是干巴爹），但是比炸大肠好是要好吃点的吧，嚼劲不错。</p><p><img src="/2019/03/21/YunNan/thumb_IMG_6738_1024.jpg" alt="thumb_IMG_6738_1024"></p><p>还有牛肉串啥的就没有图了，总的来说第一餐还是不错的，尤其是火锅蘸料。</p><p>吃过饭就直接打车去滇池，昆明这座城市坐落滇池一隅。我感觉云南的这些水的名字都特好听，比如滇池、洱海、抚仙湖、泸沽湖（云南境内四大淡水湖）。滇池太大，没办法领略全景所以只能在湖边看个大概，我们去的是一个叫海埂大坝的地方。说是叫大坝，实际上就是一片湖堤，站在湖堤上只能看到滇池的一角，但这一角的风光对于没怎么见过大湖的我们来说也已经很美了，水是很清澈的，远处的山蛮有型，就是风比较大。</p><p>当然，云南的水总是有另一个主角－－－海鸥。虽然我不知道这些成群结对的到底是不是海鸥，但这些鸟给滇池、给云南带来了完全不同的感觉，倒不是说这些鸟本身有多美，而是有种<strong>水不在深，有龙则灵</strong>的味道。</p><p><img src="/2019/03/21/YunNan/thumb_ORG_DSC00462_1024.jpg" alt="thumb_ORG_DSC00462_1024"></p><p>我个人其实不喜欢一群鸟飞起来抢食物的景象，在我看来这些鸟在某种意义上有点像云南的象征，闲适、宁静、没有纷扰，让人看见就心很静。</p><p><img src="/2019/03/21/YunNan/thumb_ORG_DSC00498_1024.jpg" alt="thumb_ORG_DSC00498_1024"></p><p>下午逛完了滇池边的大坝，我们又打车去了昆明市区的翠湖公园。翠湖公园门口有一家水果店千万不要去，其他地方卖10块钱一斤的菠萝蜜他们卖48一斤，你们怎么不上天呢？我们也是傻，但是口干舌燥，加上这个菠萝蜜看起来像是奇珍异果一样的东西，于是花了50块买了一小盒，真是亏出了shit。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00503_1024.jpg" alt="thumb_DSC00503_1024"></p><p>翠湖公园是昆明闹市中的一小颗明珠，面积不大的一个小园子，不收门票，完整走下来一大圈也就十几分钟吧，但就像我前面所说，云南昆明这地方就有一种闲适的感觉，整个公园虽然人很多，但是这一片水却颇有一种闹中取静的意思（虽然晚上肯定要被广场舞占领）。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00516_1024.jpg" alt="thumb_DSC00516_1024"></p><p><img src="/2019/03/21/YunNan/thumb_DSC00513_1024.jpg" alt="thumb_DSC00513_1024"></p><p><img src="/2019/03/21/YunNan/thumb_DSC00525_1024.jpg" alt="thumb_DSC00525_1024"></p><p>翠湖走下来，也有点累了，我们就随便在翠湖边上找了一家看着还蛮有格调的餐厅吃晚饭。餐厅就在翠湖的西门旁，叫<a href="http://www.dianping.com/shop/8907157" target="_blank" rel="noopener">茴香熙楼</a>。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00526_1024.jpg" alt="thumb_DSC00526_1024"></p><p>当这一碗我忘记是98还是198一碗的东西上上来的时候，我很想翻开字典看看“过桥米线”的定义。好吧，也可能是我无知了，反正我是觉得超出了我的认知，味道么差强人意吧，反正不如我大武汉的热干面。</p><h2 id="3-西双版纳"><a href="#3-西双版纳" class="headerlink" title="3. 西双版纳"></a><strong>3. 西双版纳</strong></h2><p>西双版纳是一个美丽的名字，其实是少数民族语言吧，说的好像是好多个民族的意思，其实这座城市叫做景洪市。这边傣族占大多数，汉族反而是少数，也有一些其他少数民族。大街上很多地方还保留了傣族的特色，随处都可以看到有关孔雀和大象的雕塑或者是记号，因为傣族人认为孔雀是吉祥之物，而大象也是很值得敬畏的。</p><p>版纳的气候接近热带，从机场到酒店一路上看见的许多树跟三亚棕榈树有点类似，好像叫铁树，对，就是铁树开花的铁树。正是由于这样热带的气候，版纳才有了现在的两大经济支柱：种茶和割胶。所谓种茶也就是非常有名的普洱，割胶呢指的就是橡胶树。</p><p>普洱茶最大的特点恐怕就是它没有保质期，放的越旧越好，就跟酿酒似的。普洱分为生普和熟普。生普就是摘下来没经过什么处理的茶叶，相对来说味道比较涩，适合饭后刮刮油，助消化；而熟普则是摘下来的茶叶经过一起发酵后的茶叶，喝起来比较温和，主要用来暖胃和安神，适合女人和老人来喝。茶其实本身是一种文化，而版纳人喜欢喝茶也是有来头的，听说版纳人一顿三餐都吃烧烤，所有能拿来烤的东西全部都拿来烤，包括所有的蔬菜，简直难以想象，烧烤摊能开通宵，夜市大排档更是不计其数，夜生活从8点开始2点才结束，在夜市上吃肉喝酒玩开心了，找地方喝上一点生普刮油，顺便跟朋友聊聊天，是版纳人的正常写照。天呐，真的自在。版纳卖的普洱茶一般是按“饼”来卖，一“饼”有7两7钱也就是357公克。我们说的普洱茶其实并不是指的某一种茶，因为不同的山头种出来的茶味道其实各不相同，但是他们都叫普洱，说到底功效上都是差不多的，只是不同的人对茶的口味需求不同，传闻有些著名的山头一年只产出几百克茶，但是要买到十几万/克，真的是可遇而不可求。</p><p>云南十九怪里讲的“老太太爬树比猴快”，说的就是这边的割胶了。所谓割胶就是爬到橡胶树上，割开一个小口子然后把树干里的橡胶原汁接出来。千万不要小看这橡胶树，工业上使用的各种手套、轮胎，还有杜蕾斯，都是加工后的橡胶制品。橡胶在版纳是一个很庞大的产业，这里有满山遍野的橡胶树，每家每户可能都占有着某一个山头的橡胶树。橡胶树大概十年成型，一批橡胶树可以割三十年，于是就有了也就是这边说的“一代橡胶一代人”，青年时期种下一批橡胶树，长到成年后可以割胶30年，这便是一代人。由于橡胶树在见光或者温度上升时就不产胶了，所以这里人们都是夜里1-2点上山割胶，早上7-8点太阳出来就收工了，这也使得版纳人的生活习惯整体节奏是偏慢的，因为在早上11点前路上都不会有什么人，前一天割胶的人还在家睡觉呢。</p><p>最后，不得不说一下傣族这边的婚恋情况了。来之前我只知道泸沽湖那边的摩梭族是母系大家庭，结果来了版纳才听说，这边的女人是以黑胖为美的咯，尤其要屁股大啊。因为在傣族家庭里，都是女人干活，男人的主要任务就是－－－陪客人喝酒聊天。现在傣族也开放了异族通婚，男人娶一个傣族女人不叫娶，都是男人入赘到傣族村寨里，每一个男的都是要经过三年的艰苦磨练才能“嫁”到傣族。不过一旦经过了考验，娶到了傣族姑娘，之后在家里就可以翘起二郎腿享受生活了，因为活都让女人干了。不得不说，这种婚恋方式还是很特别的啊。</p><p>悲催的是我们到版纳的第一天天公不作美，匆匆忙忙淋着雨去了中科院植物园和野象谷，景也没拍到，就随便po几张图把，反正这些花草树木我也看不懂。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00537_1024.jpg" alt="thumb_DSC00537_1024"></p><p><img src="/2019/03/21/YunNan/thumb_DSC00571_1024.jpg" alt="thumb_DSC00571_1024"></p><p><img src="/2019/03/21/YunNan/thumb_DSC00608_1024.jpg" alt="thumb_DSC00608_1024"></p><p>晚上在市区找了家大排档吃了点烧烤，有一种叫“纸包鱼”的吃法，其实就是生菜叶子卷了罗非鱼和粉丝，有兴趣可以尝尝把。哦对了，版纳这个城市实在是太堵了。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00625_1024.jpg" alt="thumb_DSC00625_1024"></p><p>版纳的第二天，天空终于放晴了，温度也一下子变得很高。早上直接先去了傣家村寨，傣族村寨大多是依水而建，大小不一，有大的能住上千户，小的可能只有几百户。各个村寨似乎都有着自己的一些使命，为整个傣族、傣王服务。我们参观的村寨就主要是做一些手工银饰。为了改善傣族人的生活条件，现在政府给这些村寨修建了新寨，我们现在唯一能看到的也只有新寨，新寨里主要是一些年轻力壮的猫哆哩（男人）和骚多哩（女人）接待游客或者是做一些手工，老人和小孩则是呆在老寨中。</p><p>说到傣族，就不得不先说说傣族的房子。傣族的房子是标准的全木质结构吊脚楼设计，一楼使用方型柱子架空，一方面可以防各种野兽鸟虫（方形的柱子蛇爬不上来），另一方面就是防潮所以一楼一般来说主要用来堆砌杂物（主要是干柴火），还有就是厕所也在一楼。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00628_1024.jpg" alt="thumb_DSC00628_1024"></p><p><img src="/2019/03/21/YunNan/thumb_DSC00644_1024.jpg" alt="thumb_DSC00644_1024"></p><p>起居、会客、做饭都是在二楼了。二楼不让拍照所以也没有图片可放，总的布局就是一个巨大的会客厅加上角落的一个小厨房，再就是一个用板子隔开的寝室。巨大的会客厅随时可以变成大通铺，为醉酒的朋友提供住宿。寝室有两个门，年轻人从靠外的门进入，长者从靠里的门进入，但其实在门后也是一个大通铺，一家子男女老少全部睡在一张床上。傣族是特别讲求孝道，他们认为分开睡或者加上个帘子会导致心里有隔阂，所以直到老人去世之前，一大家子一直都是睡在一起的。</p><p>傣银在傣族人生活中占着很大比重，每家每户都会备有一套银质餐具，用来盛饭或者盛水，傣族人认为银器可以帮他们过滤水中的杂志，换句话说，银器可以用来试毒。当然银饰也是非常受傣族人喜欢的，从银发簪到纯银的梳子，甚至是纯银的腰带等。女人随着年龄的长大，需要依次佩戴二指、三指、四指等宽度的腰带，这些腰带一般是由她们的丈夫亲手打造的。但是每逢重大节日（泼水节），傣族人则是会戴上各种金子，意为显富贵。</p><p>说完了生活再来说娱乐，一个村寨最大的娱乐项目就是－－－<strong>斗鸡。</strong>谁家的斗鸡赢得了比赛是无比光荣的事情，脸上倍儿有面子，傣族人斗鸡讲究小赌怡情，不伤和气。我个人觉得他们与其给我们推销1500人民币一把的纯银梳子还不如组织一点斗鸡比赛来的有意思，哈哈。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00639_1024.jpg" alt="thumb_DSC00639_1024"></p><p>下午我们游览了西双版纳原始森林公园，行前我是很期待这个景点的，但是去了才发现这个原始森林公园其实也没什么特别的，不仅很小而且感觉破破烂烂的。园区主要包括了孔雀放飞、民族歌舞表演、丛林飞跃几个板块吧。</p><p>有时候感觉一旦某个东西扎堆出现的时候，就少了一些美感。。。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00657_1024.jpg" alt="thumb_DSC00657_1024"></p><p>明显为游客而造的桥，下面的小溪是真的浑浊，不忍直视。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00683_1024.jpg" alt="thumb_DSC00683_1024"></p><p>走到最后才看见一点“原始”的东西吧。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00705_1024.jpg" alt="thumb_DSC00705_1024"></p><p>作为彩云之南的第一站，我不得不说这是一个bad start，完全没有给到我那种我期望的震撼。版纳作为一个旅游城市，没有给到游客一种很贴心和舒适的体验，还有待发展吧。</p><h2 id="4-泸沽湖"><a href="#4-泸沽湖" class="headerlink" title="4. 泸沽湖"></a><strong>4. 泸沽湖</strong></h2><p>从版纳回到丽江，并在丽江短暂的歇了一天，我们马不停蹄的赶往此行的重头戏－－－泸沽湖。泸沽湖景区属于丽江市宁蒗彝族自治县管辖，车子开出丽江没多久便进入蜿蜒的山路，秀丽的风光才真正慢慢地展开在我们眼前。</p><p>湛蓝地金沙江平缓地流淌在大山之间，山壁威严陡峭，棱角分明，甚是壮观。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00729_1024.jpg" alt="thumb_DSC00729_1024"></p><p>车子时而在山顶上飞驰，时而又钻到山脚，跨过金沙江来到另一边。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00761_1024.jpg" alt="thumb_DSC00761_1024"></p><p>在一个冷的没边儿地山顶，居然藏着一个加油站，可以远眺到玉龙雪山地几个山峰。</p><p><img src="/2019/03/21/YunNan/thumb_DSC00773_1024.jpg" alt="thumb_DSC00773_1024"></p><p>在一个冷的没边儿地山顶，居然藏着一个加油站，可以远眺到玉龙雪山地几个山峰。</p><p>泸沽湖在云南和四川的边界，一半归云南一半归四川，所以从云南和四川都可以进入泸沽湖景区。</p>]]></content>
      
      
      <categories>
          
          <category> 游记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 云南 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《非暴力沟通》</title>
      <link href="/2019/03/18/NVC/"/>
      <url>/2019/03/18/NVC/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/18/NVC/NVC.jpeg" alt></p><blockquote><p>听到批评时，我们一般会申辩、退缩或反击。<br>然而，一旦专注于彼此的观察、感受和需要，而不是反驳他人，我们便能发现内心的柔情，对自己和他人产生全新的体会。<br><a id="more"></a></p></blockquote><h1 id="非暴力沟通"><a href="#非暴力沟通" class="headerlink" title="非暴力沟通"></a>非暴力沟通</h1><h2 id="四要素"><a href="#四要素" class="headerlink" title="四要素"></a>四要素</h2><ol><li>首先，留意发生的事情。我们此刻观察到什么？不管是否喜欢，只是说出人们所做的事情。要点是，<strong>清楚地表达观察结果，而不判断或评估</strong>。</li><li>接着，<strong>表达感受</strong>。例如受伤害怕喜悦开心气氛等等。</li><li>然后，表达是什么样的<strong>需求</strong>导致了这些感受。</li><li>提出<strong>具体的请求</strong>。</li></ol><blockquote><p>我此刻的<strong>观察</strong>、<strong>感受</strong>和<strong>需要</strong>是什么，为了改善生活，我的<strong>请求</strong>是什么？</p><p>你此刻的<strong>观察</strong>、<strong>感受</strong>和<strong>需要</strong>是什么？为了赶山生活，你的<strong>请求</strong>是什么？</p><p>好的方式举例：</p><p>菲利克斯，看到咖啡桌下的两只脏袜子和电视机旁的三只，我不太高兴，应为我看重整洁，你是否愿意将袜子拿到房间或者放进洗衣机？</p></blockquote><h2 id="区分观察和评论"><a href="#区分观察和评论" class="headerlink" title="区分观察和评论"></a>区分观察和评论</h2><p>不带评论的观察是人类智力的最高形式。</p><p>非暴力沟通的第一个要素就是观察。<strong>将观察和评论混为一谈，别人就会倾向于听到批评，并反驳我们。</strong></p><h2 id="体会和表达感受"><a href="#体会和表达感受" class="headerlink" title="体会和表达感受"></a>体会和表达感受</h2><p>听到不中听的话时，我们有四种选择：</p><ol><li>认为自己犯了错。这会导致我们内疚、惭愧、甚至厌恶自己。</li><li>指责对方。这是我们可能会驳斥对方，一般会感到愤怒。</li><li>了解我们的感受和需要。这时，我们可能会发现我们有些伤心，因为我们看重信任和接纳。</li><li>用心体会他人的感受和需要，这时我们也许就会想”他伤心可能是因为他需要体贴和支持”</li></ol><p>我们通常把自己的不愉快的感受归咎于对方，以此利用对方的内疚。他人可能会因为内疚而调整行为以迎合我们，但这种行为仅仅是因为内疚，而不是考虑到了我们的感受，我们应该更多的去理解感受和自身的关系。</p><p>以下的几种行为代表我们忽略了感受和自身的关系：</p><ol><li>只提及相关的事情。”公司海报出现拼写错误使我很生气”。</li><li>只提及他人的行为。”你没有把饭吃完，妈妈很失望”。</li><li>指责他人。”我很生气，因为老板说话不算数”</li></ol><p>我们可以通过”我（感到）……因为我……”这种表达方式来认识感受和自身的关系。</p><blockquote><p>看到公司海报出现拼写错误，我很不高兴。因为我重视公司形象</p><p>你没有把饭吃完，妈妈感到很失望。因为妈妈希望你能健康成长</p><p>老板说话不算数，我很生气。因为我想有个长假去看我弟弟</p></blockquote><p>批评往往暗含着期待，对他人的批评实际上间接表达了我们尚未满足的需求。如果一个人说”你不理解我”，他实际上是渴望得到理解。如果我们通过批评来提出主张，人们的反应往往是申辩或者反击。反之，如果我们直接说出需要，其他人就较有可能作出积极的回应。</p><h2 id="请求帮助"><a href="#请求帮助" class="headerlink" title="请求帮助"></a>请求帮助</h2><p>非暴力沟通的第四个要素是请求。在表达了观察、感受和需要之后，我们请求他人的帮助。清楚的告诉对方我们希望他做什么。如果我们请求他人不做什么，对方也许会感到困惑，不知道我们到底想要什么，而且，这样的请求还容易引起别人的反感。</p><p>我们提出的请求越具体越好，如果我们的意思含糊不清，别人就难以理解我们到底想要什么。此外，使用抽象的语言还会使我们无法深入了解我们自己。（反例：我希望你给我自由！）</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这本书围绕非暴力沟通的四个要素来讲述。</p><ol><li>陈述观察到的现象而不是评论</li><li>表达我们当时的感受而不是去责怪</li><li>陈述是由于什么样的需求导致了这样的感受</li><li>提出明确和具体的请求</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis源码阅读</title>
      <link href="/2019/03/18/chewRedis/"/>
      <url>/2019/03/18/chewRedis/</url>
      
        <content type="html"><![CDATA[<p><img src="/2019/03/18/chewRedis/redis.jpeg" alt><br>收录了一些对redis源码实现的理解，持续更新…<br><a id="more"></a></p><h1 id="Redis源码阅读"><a href="#Redis源码阅读" class="headerlink" title="Redis源码阅读"></a>Redis源码阅读</h1><h1 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1 数据结构"></a>1 数据结构</h1><h2 id="1-1-动态字符串SDS"><a href="#1-1-动态字符串SDS" class="headerlink" title="1.1 动态字符串SDS"></a>1.1 动态字符串SDS</h2><p>Redis自己实现了动态字符串，相关的源码包含在sds.c和sds.h两个文件中，先来看sds.h中的相关定义。</p><ul><li>为了和C语言中的字符串兼容，redis中SDS的定义其实就是<code>char*</code></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *sds;</span><br></pre></td></tr></table></figure><ul><li>SDS完整的内存结构则是将字符串的头部分隐藏在了之际字符串的前面，以sdshdr8为例来看</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> len;</span><br><span class="line">  <span class="keyword">uint8_t</span> alloc;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> flags;</span><br><span class="line">  <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol><li><code>len</code>即是当前字符串已经占用的长度。</li><li><code>alloc</code>用于表示当前给字符串分配的长度。</li><li><code>flags</code>低三位用来区分当前结构的具体类型。</li><li>各个header的定义中最后有一个<code>char buf[]</code>。我们注意到这是一个没有指明长度的字符数组，这是C语言中定义字符数组的一种特殊写法，称为柔性数组（flexible array member），只能定义在一个结构体的最后一个字段上。它在这里只是起到一个标记的作用，表示在flags字段后面就是一个字符数组，或者说，它指明了紧跟在flags字段后面的这个字符数组在结构体中的偏移位置。而程序在为header分配的内存的时候，数组本身并不占用内存空间。如果计算<code>sizeof(struct sdshdr8)</code>的值，那么结果是3个字节。</li><li>结构体采用<code>__attribute__ ((__packed__))</code>的定义方式是为了让编译器<strong>紧凑地</strong>分配空间，而不是按照字节对齐地方式，这样做的目的是为了让结构体内的所有变量能在内存种上下紧密排列，以便快速寻址。</li></ol><ul><li><code>SDS_HDR_VAR</code>和<code>SDS_HDR</code>这两个宏用于获取SDS头的位置</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_8  1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_16 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_32 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_64 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SDS_TYPE_5_LEN(f) ((f)&gt;&gt;SDS_TYPE_BITS)</span></span><br></pre></td></tr></table></figure><ul><li>SDS的基本操作封装</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;                <span class="comment">/*获取sds字符串长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetlen</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span></span>;      <span class="comment">/*设置sds字符串长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdsinclen</span><span class="params">(sds s, <span class="keyword">size_t</span> inc)</span></span>;         <span class="comment">/*增加sds字符串长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsalloc</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;              <span class="comment">/*获取sds字符串容量*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sdssetalloc</span><span class="params">(sds s, <span class="keyword">size_t</span> newlen)</span></span>;    <span class="comment">/*设置sds字符串容量*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdsavail</span><span class="params">(<span class="keyword">const</span> sds s)</span></span>;              <span class="comment">/*获取sds字符串空余空间*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">sdsHdrSize</span><span class="params">(<span class="keyword">char</span> type)</span></span>;                 <span class="comment">/*获取当前类型type的头长度*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">char</span> <span class="title">sdsReqType</span><span class="params">(<span class="keyword">size_t</span> string_size)</span></span>;       <span class="comment">/*获取请求长度size对应的类型*/</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  获取当前sds的已使用长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> size_t <span class="title">sdslen</span><span class="params">(<span class="keyword">const</span> sds s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> flags = s[<span class="number">-1</span>];</span><br><span class="line">  <span class="keyword">switch</span>(flags&amp;SDS_TYPE_MASK) &#123;</span><br><span class="line">      <span class="keyword">case</span> SDS_TYPE_5:</span><br><span class="line">          <span class="keyword">return</span> SDS_TYPE_5_LEN(flags);</span><br><span class="line">      <span class="keyword">case</span> SDS_TYPE_8:</span><br><span class="line">          <span class="keyword">return</span> SDS_HDR(<span class="number">8</span>,s)-&gt;len;</span><br><span class="line">      <span class="keyword">case</span> SDS_TYPE_16:</span><br><span class="line">          <span class="keyword">return</span> SDS_HDR(<span class="number">16</span>,s)-&gt;len;</span><br><span class="line">      <span class="keyword">case</span> SDS_TYPE_32:</span><br><span class="line">          <span class="keyword">return</span> SDS_HDR(<span class="number">32</span>,s)-&gt;len;</span><br><span class="line">      <span class="keyword">case</span> SDS_TYPE_64:</span><br><span class="line">          <span class="keyword">return</span> SDS_HDR(<span class="number">64</span>,s)-&gt;len;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>flags的获取使用了<code>s[-1]</code>的方式，这与之前进行结构体声明是的紧凑分配内存息息相关。</p></li><li><p><code>inline</code>关键字是在C语言中表示<strong>内联函数</strong>。在c中,为了解决一些频繁调用的小函数大量消耗栈空间或是叫栈内存的问题，特别的引入了inline修饰符，表示为内联函数。inline函数仅仅是一个建议,对编译器的建议,所以最后能否真正内联,看编译器的意思,它如果认为函数不复杂,能在调用点展开,就会真正内联,并不是说声明了内联就会内联,声明内联只是一个建议而已。</p></li></ol><ul><li>sds.c中定义了一些对sds的申请，设置长度，更新长度，新分配长度等操作</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">len = sdslen(s);</span><br><span class="line">sh = (<span class="keyword">char</span>*)s-sdsHdrSize(oldtype);</span><br><span class="line">newlen = (len+addlen);</span><br><span class="line"><span class="keyword">if</span> (newlen &lt; SDS_MAX_PREALLOC)</span><br><span class="line">  newlen *= <span class="number">2</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    newlen += SDS_MAX_PREALLOC;</span><br></pre></td></tr></table></figure><p>  有趣的是，当需要扩充长度时，如果新的长度不足<code>SDS_MAX_PREALLOC＝1024*1024</code>时，会将申请的长度乘以2作为新分配的长度，而当新长度超过<code>SDS_MAX_PREALLOC</code>时则再新长度后扩增一段<code>SDS_MAX_PREALLOC</code>。</p><h2 id="1-2-双向链表ADLIST"><a href="#1-2-双向链表ADLIST" class="headerlink" title="1.2 双向链表ADLIST"></a>1.2 双向链表ADLIST</h2><p>双向链表的实现相对来说比较直白</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listIter</span> &#123;</span></span><br><span class="line">    listNode *next;</span><br><span class="line">    <span class="keyword">int</span> direction;</span><br><span class="line">&#125; listIter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">void</span> *(*dup)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">void</span> (*<span class="built_in">free</span>)(<span class="keyword">void</span> *ptr);</span><br><span class="line">    <span class="keyword">int</span> (*match)(<span class="keyword">void</span> *ptr, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h2 id="1-3-字典-DICT"><a href="#1-3-字典-DICT" class="headerlink" title="1.3 字典 DICT"></a>1.3 字典 DICT</h2><p>Redis对字典的实现，首先是字典单个条项的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">        <span class="keyword">double</span> d;</span><br><span class="line">    &#125; v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><ul><li><code>dictEntry</code> 是字典的一条记录，也就是所谓的桶(bucket)</li><li><code>key</code>是键</li><li><code>v</code>是值</li><li><code>next</code>是指向筒内下一条记录的指针</li></ul><p>字典类型的定义则包含了本类型的字典对应的相关处理函数，包括哈希计算函数和元素比较函数等。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictType</span> &#123;</span></span><br><span class="line">    <span class="comment">/*哈希函数定义*/</span></span><br><span class="line">    <span class="keyword">uint64_t</span> (*hashFunction)(<span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*keyDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> *(*valDup)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *obj);</span><br><span class="line">    <span class="comment">/*比较函数定义*/</span></span><br><span class="line">    <span class="keyword">int</span> (*keyCompare)(<span class="keyword">void</span> *privdata, <span class="keyword">const</span> <span class="keyword">void</span> *key1, <span class="keyword">const</span> <span class="keyword">void</span> *key2);</span><br><span class="line">    <span class="keyword">void</span> (*keyDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *key);</span><br><span class="line">    <span class="keyword">void</span> (*valDestructor)(<span class="keyword">void</span> *privdata, <span class="keyword">void</span> *obj);</span><br><span class="line">&#125; dictType;</span><br></pre></td></tr></table></figure><p>字典本身的定义以及哈希表的定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is our hash table structure. Every dictionary has two of this as we</span></span><br><span class="line"><span class="comment"> * implement incremental rehashing, for the old to the new table. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line">    dictType *type;</span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">long</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><ul><li><code>ditcht</code>是哈希表的定义，包括了一个指向若干个<code>＊dictEntry</code>类型的数组头指针<code>table</code>，以及当前哈希表的大小<code>size</code>，还有用于计算索引项的<code>sizemask</code>，<code>used</code>是当前哈希表中已经占用的数量。</li><li>字典本身定义在<code>dict</code>中，包括当前字典的类型<code>type</code>，两张哈希表<code>ht[2]</code>，渐进式哈希的进度标识<code>rehashidx</code>，<code>iterators</code>则表示当前绑定到该字典上的遍历体个数。</li></ul><p>dict在内存中的结构如下图：</p><p><img src="/2019/03/18/chewRedis/dict_mem.png" alt="内存中的字典结构图"></p><p>Redis对于字典的设计里，一大特点就是采用了两张哈希表，并且在使用过程中不断地通过<code>dictRehash</code>方法将一张哈希表的数据迁移到另一张表中，以达到扩容的目的，具体代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dictRehash</span><span class="params">(dict *d, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty_visits = n*<span class="number">10</span>; <span class="comment">/* Max number of empty buckets to visit. */</span></span><br><span class="line">    <span class="keyword">if</span> (!dictIsRehashing(d)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n-- &amp;&amp; d-&gt;ht[<span class="number">0</span>].used != <span class="number">0</span>) &#123;</span><br><span class="line">        dictEntry *de, *nextde;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Note that rehashidx can't overflow as we are sure there are more</span></span><br><span class="line"><span class="comment">         * elements because ht[0].used != 0 */</span></span><br><span class="line">        assert(d-&gt;ht[<span class="number">0</span>].size &gt; (<span class="keyword">unsigned</span> <span class="keyword">long</span>)d-&gt;rehashidx);</span><br><span class="line">        <span class="keyword">while</span>(d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            d-&gt;rehashidx++;</span><br><span class="line">            <span class="keyword">if</span> (--empty_visits == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        de = d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx];</span><br><span class="line">        <span class="comment">/* Move all the keys in this bucket from the old to the new hash HT */</span></span><br><span class="line">        <span class="keyword">while</span>(de) &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> h;</span><br><span class="line"></span><br><span class="line">            nextde = de-&gt;next;</span><br><span class="line">            <span class="comment">/* Get the index in the new hash table */</span></span><br><span class="line">            h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="number">1</span>].sizemask;</span><br><span class="line">            de-&gt;next = d-&gt;ht[<span class="number">1</span>].table[h];</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].table[h] = de;</span><br><span class="line">            d-&gt;ht[<span class="number">0</span>].used--;</span><br><span class="line">            d-&gt;ht[<span class="number">1</span>].used++;</span><br><span class="line">            de = nextde;</span><br><span class="line">        &#125;</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>].table[d-&gt;rehashidx] = <span class="literal">NULL</span>;</span><br><span class="line">        d-&gt;rehashidx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check if we already rehashed the whole table... */</span></span><br><span class="line">    <span class="keyword">if</span> (d-&gt;ht[<span class="number">0</span>].used == <span class="number">0</span>) &#123;</span><br><span class="line">        zfree(d-&gt;ht[<span class="number">0</span>].table);</span><br><span class="line">        d-&gt;ht[<span class="number">0</span>] = d-&gt;ht[<span class="number">1</span>];</span><br><span class="line">        _dictReset(&amp;d-&gt;ht[<span class="number">1</span>]);</span><br><span class="line">        d-&gt;rehashidx = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More to rehash... */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>传入的参数<code>n</code>表示了本次做rehash动作中，遍历的空桶上限为<code>n*10</code>个</p></li><li><p>开始进行rehash后，字典结构体域中<code>d-&gt;rehashidx</code>将被设置为当前已经从旧哈希表迁移到新哈希表的索引最大值，而<code>d-&gt;rehashidx＝－1</code>时表明当前哈希表未进行迁移。迁移开始后所有的插入操作将在新表中进行。</p></li><li><p>依次将旧哈希表中的数据在新表中进行插入。</p></li><li><p>旧表的数据全部插入到新表之后</p><ol><li><p>将旧表的空间<code>free</code>掉</p></li><li><p>将<code>ht[0]</code>重新指向新表<code>ht[1]</code>原本指向的空间，<code>d-&gt;rehashidx</code>设置为-1</p></li><li><p>将<code>ht[1]</code>中的指针都清空，此时<code>ht[1]</code>成为一张空表，需要在下次重新分配。</p></li></ol></li></ul><p>通过渐进式哈希的设计方法，Redis能在原哈希表需要进行扩容时，逐步将旧表的内容迁移到新表，下图是相关过程。</p><p><img src="/2019/03/18/chewRedis/dict_rehash1.png" alt="dict_rehash1"><br><img src="/2019/03/18/chewRedis/dict_rehash2.png" alt="dict_rehash2"><br><img src="/2019/03/18/chewRedis/dict_rehash3.png" alt="dict_rehash3"><br><img src="/2019/03/18/chewRedis/dict_rehash4.png" alt="dict_rehash4"><br><img src="/2019/03/18/chewRedis/dict_rehash5.png" alt="dict_rehash5"><br><img src="/2019/03/18/chewRedis/dict_rehash6.png" alt="dict_rehash6"></p><h2 id="1-4-跳跃表"><a href="#1-4-跳跃表" class="headerlink" title="1.4 跳跃表"></a>1.4 跳跃表</h2><p>跳跃表是一种随机化的数据结构，在查找、插入和删除这些字典操作上，其效率可比拟于平衡二叉树（如红黑树），大多数操作只需要<strong>O(log n)</strong>平均时间。跳跃表基于有序单链表，在链表的基础上，每个结点不只包含一个指针，还可能包含多个指向后继结点的指针，这样就可以跳过一些不必要的结点，从而加快查找、删除等操作。如下图就是一个跳跃表：</p><p><img src="/2019/03/18/chewRedis/skiplist.png" alt="skiplist"></p><p>Redis的跳跃表实现跟WilliamPugh在《Skip Lists: A Probabilistic Alternative to Balanced Trees》中描述的跳跃表算法类似，只是有三点不同：</p><ol><li><p>允许重复分数；</p></li><li><p>排序不止根据分数，还可能根据成员对象（当分数相同时）；</p></li><li><p>有一个前继指针，因此在第1层，就形成了一个双向链表，从而可以方便的从表尾向表头遍历，用于ZREVRANGE命令的实现。</p></li></ol><p><strong>有序集合</strong>使用两种数据结构来实现，从而可以使插入和删除操作达到O(log(N))的时间复杂度。这两种数据结构是哈希表和跳跃表。向哈希表添加元素，用于将成员对象映射到分数；同时将该元素添加到跳跃表，以分数进行排序。</p><p>Redis对跳跃表的相关结构定义在<code>server.h</code>中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_MAXLEVEL 64 <span class="comment">/* Should be enough for 2^64 elements */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ZSKIPLIST_P 0.25      <span class="comment">/* Skiplist P = 1/4 */</span></span></span><br><span class="line"><span class="comment">/* ZSETs use a specialized version of Skiplists */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    sds ele;</span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> span;</span><br><span class="line">    &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">    <span class="keyword">int</span> level;</span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zset</span> &#123;</span></span><br><span class="line">    dict *dict;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line">&#125; zset;</span><br></pre></td></tr></table></figure><ul><li><p>跳跃表节点又使用了柔性数组<code>level</code>的概念</p></li><li><p><code>ZSKIPLIST_MAXLEVEL</code>定义了单个节点最多存储的层数</p></li><li><p><code>ZSKIPLIST_P</code>用于计算节点的随机层数，此处设置为0.25。从以下代码可见，level＝1的概率为0.75，而level＝2的概率则为0.25*0.75，依次类推，level值越大的概率越低，这即是所谓的<strong>幂次定律(powerlaw)</strong>。</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Returns a random level for the new skiplist node we are going to create.</span></span><br><span class="line"><span class="comment"> * The return value of this function is between 1 and ZSKIPLIST_MAXLEVEL</span></span><br><span class="line"><span class="comment"> * (both inclusive), with a powerlaw-alike distribution where higher</span></span><br><span class="line"><span class="comment"> * levels are less likely to be returned. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">zslRandomLevel</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> ((random()&amp;<span class="number">0xFFFF</span>) &lt; (ZSKIPLIST_P * <span class="number">0xFFFF</span>))</span><br><span class="line">        level += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> (level&lt;ZSKIPLIST_MAXLEVEL) ? level : ZSKIPLIST_MAXLEVEL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>level</code> 当中的<code>span</code>用来记录当前节点到该层级的下一个节点的距离，这样可以方便计算某一个节点在有序链表中的排名。</li></ul><h2 id="1-5-hyperloglog"><a href="#1-5-hyperloglog" class="headerlink" title="1.5 hyperloglog"></a>1.5 hyperloglog</h2><p>有点复杂啊</p><h1 id="2-内存编码"><a href="#2-内存编码" class="headerlink" title="2 内存编码"></a>2 内存编码</h1><h2 id="2-1-整数集合intset"><a href="#2-1-整数集合intset" class="headerlink" title="2.1 整数集合intset"></a>2.1 整数集合intset</h2><p>整数集合的相关代码在intset.c和intset.h中，说到底就是一个排序的整数数组，定义如下，与redis中<code>sds</code>的定义类似，<code>intset</code>结构体主要定义了<code>header</code>，结构体的末尾依旧是一个柔性数组<code>contents</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding;</span><br><span class="line">    <span class="keyword">uint32_t</span> length;</span><br><span class="line">    <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure><p>其中<code>encoding</code>可能是16位、32位或者是64位，通过数据类型的不同来保证最大限度的节省内存，但是所有元素的数据类型是相同的，这意味着整个数组的数据类型取决于最大的那个数。在<code>endianconv.c</code>和<code>endianconv.h</code>中设计了几个宏用来进行大小端的转换。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (BYTE_ORDER == LITTLE_ENDIAN)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev16ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev32ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev64ifbe(p) ((void)(0))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev16ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev32ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev64ifbe(v) (v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev16ifbe(p) memrev16(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev32ifbe(p) memrev32(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> memrev64ifbe(p) memrev64(p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev16ifbe(v) intrev16(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev32ifbe(v) intrev32(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> intrev64ifbe(v) intrev64(v)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>这些宏最终都对应到以下三个函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Toggle the 16 bit unsigned integer pointed by *p from little endian to</span></span><br><span class="line"><span class="comment"> * big endian */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev16</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Toggle the 32 bit unsigned integer pointed by *p from little endian to</span></span><br><span class="line"><span class="comment"> * big endian */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev32</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Toggle the 64 bit unsigned integer pointed by *p from little endian to</span></span><br><span class="line"><span class="comment"> * big endian */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">memrev64</span><span class="params">(<span class="keyword">void</span> *p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *x = p, t;</span><br><span class="line"></span><br><span class="line">    t = x[<span class="number">0</span>];</span><br><span class="line">    x[<span class="number">0</span>] = x[<span class="number">7</span>];</span><br><span class="line">    x[<span class="number">7</span>] = t;</span><br><span class="line">    t = x[<span class="number">1</span>];</span><br><span class="line">    x[<span class="number">1</span>] = x[<span class="number">6</span>];</span><br><span class="line">    x[<span class="number">6</span>] = t;</span><br><span class="line">    t = x[<span class="number">2</span>];</span><br><span class="line">    x[<span class="number">2</span>] = x[<span class="number">5</span>];</span><br><span class="line">    x[<span class="number">5</span>] = t;</span><br><span class="line">    t = x[<span class="number">3</span>];</span><br><span class="line">    x[<span class="number">3</span>] = x[<span class="number">4</span>];</span><br><span class="line">    x[<span class="number">4</span>] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整数集合类型提供了一些基本的操作函数</p><ul><li><p>标准的二分查找，用来定位<code>value</code>是否在原<code>intset</code>中，存在则返回1，不存在则返回0，<code>pos</code>用来返回元素<code>value</code>应该插入的位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Search for the position of "value". Return 1 when the value was found and</span></span><br><span class="line"><span class="comment"> * sets "pos" to the position of the value within the intset. Return 0 when</span></span><br><span class="line"><span class="comment"> * the value is not present in the intset and sets "pos" to the position</span></span><br><span class="line"><span class="comment"> * where "value" can be inserted. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> uint8_t <span class="title">intsetSearch</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value, <span class="keyword">uint32_t</span> *pos)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> min = <span class="number">0</span>, max = intrev32ifbe(is-&gt;length)<span class="number">-1</span>, mid = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int64_t</span> cur = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* The value can never be found when the set is empty */</span></span><br><span class="line">    <span class="keyword">if</span> (intrev32ifbe(is-&gt;length) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Check for the case where we know we cannot find the value,</span></span><br><span class="line"><span class="comment">         * but do know the insert position. */</span></span><br><span class="line">        <span class="keyword">if</span> (value &gt; _intsetGet(is,max)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = intrev32ifbe(is-&gt;length);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; _intsetGet(is,<span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pos) *pos = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(max &gt;= min) &#123;</span><br><span class="line">        mid = ((<span class="keyword">unsigned</span> <span class="keyword">int</span>)min + (<span class="keyword">unsigned</span> <span class="keyword">int</span>)max) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        cur = _intsetGet(is,mid);</span><br><span class="line">        <span class="keyword">if</span> (value &gt; cur) &#123;</span><br><span class="line">            min = mid+<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &lt; cur) &#123;</span><br><span class="line">            max = mid<span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (value == cur) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = mid;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pos) *pos = min;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编码方式需要提升时，先对整个intset的空间进行扩容，且多分配一个元素的空间。然后从后往前依次的对原本intset中的元素的位置进行调整。这里设计精妙的地方在于，调用这个函数之前一定是知道待加入的元素<code>value</code>要么是太大或者是太小，从而超过了原本<code>encoding</code>所能表示的范围，于是<code>prepend</code>用来记录<code>value</code>的正负值，因为<code>value</code>要么加在当前数组的最左侧或者是最右侧。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Upgrades the intset to a larger encoding and inserts the given integer. */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> intset *<span class="title">intsetUpgradeAndAdd</span><span class="params">(intset *is, <span class="keyword">int64_t</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> curenc = intrev32ifbe(is-&gt;encoding);</span><br><span class="line">    <span class="keyword">uint8_t</span> newenc = _intsetValueEncoding(value);</span><br><span class="line">    <span class="keyword">int</span> length = intrev32ifbe(is-&gt;length);</span><br><span class="line">    <span class="keyword">int</span> prepend = value &lt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* First set new encoding and resize */</span></span><br><span class="line">    is-&gt;encoding = intrev32ifbe(newenc);</span><br><span class="line">    is = intsetResize(is,intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Upgrade back-to-front so we don't overwrite values.</span></span><br><span class="line"><span class="comment">     * Note that the "prepend" variable is used to make sure we have an empty</span></span><br><span class="line"><span class="comment">     * space at either the beginning or the end of the intset. */</span></span><br><span class="line">    <span class="keyword">while</span>(length--)</span><br><span class="line">        _intsetSet(is,length+prepend,_intsetGetEncoded(is,length,curenc));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set the value at the beginning or the end. */</span></span><br><span class="line">    <span class="keyword">if</span> (prepend)</span><br><span class="line">        _intsetSet(is,<span class="number">0</span>,value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _intsetSet(is,intrev32ifbe(is-&gt;length),value);</span><br><span class="line">    is-&gt;length = intrev32ifbe(intrev32ifbe(is-&gt;length)+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="2-2-压缩列表ziplist"><a href="#2-2-压缩列表ziplist" class="headerlink" title="2.2 压缩列表ziplist"></a>2.2 压缩列表ziplist</h2><p>redis中的压缩列表通过特殊的内存编排方式，极大程度上做到了节约内存，实现的功能类似一个队列，可以存放数字或者<code>string</code>类型的元素，对于队列元素的<code>push</code>和<code>pop</code>操作都能做到<code>O(1)</code>的时间复杂度。但是由于<code>push</code>和<code>pop</code>操作都会触发内存的重新分配，故实际的时间复杂度与整个列表大小也是相关的。</p><p>列表的整体编排方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;zlbytes&gt; &lt;zltail&gt; &lt;zllen&gt; &lt;entry&gt; &lt;entry&gt; ... &lt;entry&gt; &lt;zlend&gt;</span><br></pre></td></tr></table></figure><ul><li><code>zlbytes</code>的类型是<code>uint32_t</code>，用于表示整个列表所占用的字节数（包括<code>zlbytes</code>本身所占用的4个字节)，存储整个列表的大小有利于在需要扩容时不必遍历整个列表。</li><li><code>zltial</code>的类型是<code>uint32_t</code>，用于存放列表中最后一个元素的偏移量，这样可以保证<code>pop</code>操作的时间复杂度为<code>O(1)</code>。</li><li><code>zllen</code>的类型是<code>uint16_t</code>，用于表示列表中元素的个数。当列表中的元素个数超过<code>2^16-2</code>的时候，<code>zllen</code>被设置为<code>2^16-1</code>，这时候就需要遍历整个列表来获取元素个数。</li><li><code>zlend</code>的类型是<code>uint8_t</code>，这是一个特殊的单字节块用于标记列表的结尾，被设置为255，其他正常的元素块均不会以255开头。</li></ul><p>列表中的元素块<code>&lt;entry&gt;</code>有单独的编码方式，以做到最大化利用内存。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;prevlen&gt; &lt;encoding&gt; &lt;entry-data&gt;</span><br></pre></td></tr></table></figure><ul><li><p><code>prevlen</code> 域用于存储的是前一个元素块的长度。</p><ol><li>当前一个元素块的长度小于254字节时，<code>prevlen</code>只占用1个字节，存储一个0-253大小的数字。表达方式如下<br> <code>&lt;prevlen from 0 to 253&gt; &lt;encoding&gt; &lt;entry&gt;</code></li><li>当前一个元素块的长度大于等于254字节时，<code>prevlen</code>此时占用5个字节，第一个字节被设置为<code>0xFE</code>，之后的4个字节用于表示前一个元素块的具体长度。表达方式如下<br> <code>0xFE &lt;4 bytes unsigned little endian prevlen&gt; &lt;encoding&gt; &lt;entry&gt;</code> </li></ol></li><li><p><code>encoding</code> 域用于表示当前存储的元素类型，一般分为<code>string</code>或者是<code>integer</code>。</p><ul><li><p>当<code>encoding</code>用于表示<code>string</code>时，<code>encoding</code>域的第一个字节的前两个bit可以是<code>00</code>,<code>01</code>,<code>10</code>：</p><ol><li><code>|00pppppp|</code><br>当<code>string</code>的长度小于63个字节时，<code>encoding</code>占用1个字节，此时首字节的前两个bit为<code>00</code>，后6个bit用来表示<code>string</code>的具体长度。</li><li><code>|01pppppp|qqqqqqqq|</code><br>当<code>string</code> 的长度大于63个字节但小于16383（14bits）字节时，<code>encoding</code>占用两个字节，首字节的前两个bit为<code>01</code>，后6个bit和第二个字节一起用于表示<code>string</code>的具体长度。这里的14bit数字为大端表示。</li><li><code>|10000000|qqqqqqqq|rrrrrrrr|ssssssss|tttttttt|</code><br>当<code>string</code> 的长度大于16383时，<code>encoding</code>占用5个字节，首字节的前两个bit被设置为<code>10</code>，后6个bit被设置为0。其后的4个字节用来表示<code>string</code>的具体长度。这里的32bit数字为大端表示。</li></ol></li><li><p>当<code>encoding</code>用于表示<code>number</code>时，<code>encoding</code>域的首字节的前两个bit应该是<code>11</code>：</p><ol><li><code>|11000000|</code><br>紧随其后的2个字节用于表示一个uint16_t类型的数字。</li><li><code>|11010000|</code><br>其后的4个字节用于表示一个uint32_t类型的数字。</li><li><code>|11100000|</code><br>其后的8个字节用于表示一个uint64_t类型的数字。</li><li><code>|11110000|</code><br>其后的3个字节用于表示一个24 bit signed 类型的数字。</li><li><code>|11111110|</code><br>其后的1个字节用于表示一个8 bit signed 类型的数字。</li><li><code>|1111xxxx|</code><br><code>xxxx</code> 直接用于表示一个数字，取值范围从 <code>0001</code> 到 <code>1101</code>，但是实际上只可以表示从0-12这13个数字，这意味着次时表示的数字应该是<code>xxxx</code>所代表的数字减1。</li></ol></li></ul></li></ul><h1 id="3-数据类型的实现"><a href="#3-数据类型的实现" class="headerlink" title="3 数据类型的实现"></a>3 数据类型的实现</h1><h2 id="3-1-Object"><a href="#3-1-Object" class="headerlink" title="3.1 Object"></a>3.1 Object</h2><p>redis中对象的实现，首先是<code>object</code>的定义，redis这里为节省结构体的空间，采用了<strong>位域</strong>的用法，即<code>type</code>和<code>endcoding</code>其实分别占用同一个字节的前四位和后四位。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits access time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;</span><br><span class="line">    <span class="keyword">void</span> *ptr;</span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure><p><code>type</code> 域：用于表示当前的对象实际的类型，定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_STRING 0    <span class="comment">/* String object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_LIST 1      <span class="comment">/* List object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_SET 2       <span class="comment">/* Set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ZSET 3      <span class="comment">/* Sorted set object. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_HASH 4      <span class="comment">/* Hash object. */</span></span></span><br></pre></td></tr></table></figure><p><code>encoding</code> 域为当前对象的编码方式,redis中对象的编码类型分为以下几种</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_RAW 0     <span class="comment">/* Raw representation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INT 1     <span class="comment">/* Encoded as integer */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_HT 2      <span class="comment">/* Encoded as hash table */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPMAP 3  <span class="comment">/* Encoded as zipmap */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_LINKEDLIST 4 <span class="comment">/* No longer used: old list encoding. */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_ZIPLIST 5 <span class="comment">/* Encoded as ziplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_INTSET 6  <span class="comment">/* Encoded as intset */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_SKIPLIST 7  <span class="comment">/* Encoded as skiplist */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_EMBSTR 8  <span class="comment">/* Embedded sds string encoding */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_QUICKLIST 9 <span class="comment">/* Encoded as linked list of ziplists */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_ENCODING_STREAM 10 <span class="comment">/* Encoded as a radix tree of listpacks */</span></span></span><br></pre></td></tr></table></figure><p><code>refcount</code> 域：这里redis使用 <code>refcount</code> 域来做 <em>对象共享</em> ， 需要注意的是当设置了服务器使用的最大内存时，共享对象会被弃用，因为每个<code>key</code>自身需要存储<code>lru</code>字段。具体的内容可以参考<a href="http://redisbook.com/preview/object/share_object.html" target="_blank" rel="noopener">redis对象共享</a></p><p><code>lru</code> 域：当设置服务器可使用的最大内存时，服务器会使用算法将一些<code>key</code>轮转出去，跟操作系统出现内存不足时的操作类似。</p><p>redis里面的<code>object</code>对象只是在基础数据类型之上封装了一层，这样可以方便底层的一些基础命令去封装接口，形式上有点类似面向接口的编程方法，对于<code>object</code>本身来说，<code>ptr</code> 域直接指向了该<code>object</code>对应的类型。  </p><p>各种类型的对象所对应的底层实现方式如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">robj *<span class="title">createQuicklistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    quicklist *l = quicklistCreate();</span><br><span class="line">    robj *o = createObject(OBJ_LIST,l);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_QUICKLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_LIST,zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*Set集合类型的对象，在底层就是一个dict结构，对应的编码类型是HT*/</span></span><br><span class="line"><span class="function">robj *<span class="title">createSetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    dict *d = dictCreate(&amp;setDictType,<span class="literal">NULL</span>);</span><br><span class="line">    robj *o = createObject(OBJ_SET,d);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_HT;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*整型结合Intset在底层则是使用列表实现的(有序数组)*/</span></span><br><span class="line"><span class="function">robj *<span class="title">createIntsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    intset *is = intsetNew();</span><br><span class="line">    robj *o = createObject(OBJ_SET,is);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_INTSET;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*hash对象是一个压缩列表*/</span></span><br><span class="line"><span class="function">robj *<span class="title">createHashObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_HASH, zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*有序列表zset对象，底层的实现是一个dict＋压缩列表*/</span></span><br><span class="line"><span class="function">robj *<span class="title">createZsetObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    zset *zs = zmalloc(<span class="keyword">sizeof</span>(*zs));</span><br><span class="line">    robj *o;</span><br><span class="line"></span><br><span class="line">    zs-&gt;dict = dictCreate(&amp;zsetDictType,<span class="literal">NULL</span>);</span><br><span class="line">    zs-&gt;zsl = zslCreate();</span><br><span class="line">    o = createObject(OBJ_ZSET,zs);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_SKIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createZsetZiplistObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *zl = ziplistNew();</span><br><span class="line">    robj *o = createObject(OBJ_ZSET,zl);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_ZIPLIST;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createStreamObject</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    stream *s = streamNew();</span><br><span class="line">    robj *o = createObject(OBJ_STREAM,s);</span><br><span class="line">    o-&gt;encoding = OBJ_ENCODING_STREAM;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">robj *<span class="title">createModuleObject</span><span class="params">(moduleType *mt, <span class="keyword">void</span> *value)</span> </span>&#123;</span><br><span class="line">    moduleValue *mv = zmalloc(<span class="keyword">sizeof</span>(*mv));</span><br><span class="line">    mv-&gt;type = mt;</span><br><span class="line">    mv-&gt;value = value;</span><br><span class="line">    <span class="keyword">return</span> createObject(OBJ_MODULE,mv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-数据库的实现"><a href="#4-数据库的实现" class="headerlink" title="4 数据库的实现"></a>4 数据库的实现</h1><h1 id="5-客户端和服务器"><a href="#5-客户端和服务器" class="headerlink" title="5 客户端和服务器"></a>5 客户端和服务器</h1>]]></content>
      
      
      <categories>
          
          <category> 开源项目学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> 开源 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
